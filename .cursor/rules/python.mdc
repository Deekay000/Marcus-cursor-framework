---
description: Python-specific coding standards applied only to .py files.
alwaysApply: false
---
CRITICAL: Frontmatter Required
yaml---
description: "Python coding standards for all .py files in this project"
globs: ["**/*.py"]
alwaysApply: false
---
Note: alwaysApply: false means this rule activates only when a .py file is open or being discussed.
Complete Template
markdown---
description: "Python coding standards for all .py files in this project"
globs: ["**/*.py"]
alwaysApply: false
---

# Python Standards

## Code Style

### Formatter
- Tool: Black
- Line length: 88 characters
- Run: `black .`

### Type Hints (MANDATORY)
```python
# ✅ CORRECT
def process_user(user_id: str, options: dict | None = None) -> User:
    """Process user with given options."""
    pass

# ❌ WRONG - No type hints
def process_user(user_id, options=None):
    pass
```

### Docstrings (Google Style)
```python
def function_name(param1: Type, param2: Type) -> ReturnType:
    """Short one-line description.

    Longer description if needed.

    Args:
        param1: Description of param1.
        param2: Description of param2.

    Returns:
        Description of return value.

    Raises:
        ErrorType: When this error occurs.
    """
    pass
```

---

## Import Order
```python
# 1. Standard library
import asyncio
import logging
from dataclasses import dataclass
from typing import Optional, List

# 2. Third-party
import numpy as np
from fastapi import FastAPI
from pydantic import BaseModel

# 3. Local
from .models import User
from .utils import helper
```

**Alphabetize within each group.**

---

## Async Patterns (MANDATORY for I/O)
```python
# ✅ CORRECT: Async I/O
async def fetch_data(url: str) -> dict:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.json()

# ❌ WRONG: Blocking I/O
def fetch_data(url: str) -> dict:
    return requests.get(url).json()  # BLOCKS EVENT LOOP
```

---

## Logging (NEVER use print())
```python
import logging

logger = logging.getLogger(__name__)

# ✅ CORRECT
logger.info("Processing started")
logger.warning(f"Latency exceeded: {ms:.1f}ms")
logger.error(f"Failed to connect: {e}")

# ❌ WRONG
print("Processing started")
print(f"Error: {e}")
```

---

## Error Handling Pattern
```python
class ProcessingError(Exception):
    """Base exception for processing errors."""
    pass

async def process_with_fallback(data: InputType) -> OutputType:
    """Process with graceful degradation."""
    try:
        return await primary_processor(data)
    except PrimaryError as e:
        logger.warning(f"Primary failed: {e}, using fallback")
        return await fallback_processor(data)
    except Exception as e:
        logger.error(f"All processors failed: {e}")
        return get_safe_default()
```

---

## FastAPI Endpoint Pattern
```python
from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown logic."""
    logger.info("Starting server...")
    await initialize_resources()
    yield
    logger.info("Shutting down...")
    await cleanup_resources()

app = FastAPI(lifespan=lifespan)

@app.get("/health")
async def health_check() -> dict:
    """Health check endpoint (MANDATORY)."""
    return {"status": "healthy"}
```

---

## Data Models
```python
from dataclasses import dataclass
from pydantic import BaseModel, Field

# For internal use
@dataclass
class InternalState:
    value: float
    timestamp: str

# For API validation
class APIRequest(BaseModel):
    content: str = Field(..., min_length=1, max_length=2000)
    options: dict | None = None
```

---

## Testing Pattern
```python
import pytest
from unittest.mock import AsyncMock, patch

@pytest.fixture
def sample_input() -> dict:
    """Sample input fixture."""
    return {"key": "value"}

@pytest.mark.asyncio
async def test_process_success(sample_input):
    """Test successful processing."""
    result = await process(sample_input)
    assert result is not None
    assert "expected_key" in result

@pytest.mark.asyncio
async def test_fallback_on_error():
    """Test graceful degradation."""
    with patch("module.primary", side_effect=Error("fail")):
        result = await process_with_fallback(input)
    assert result is not None  # Fallback worked
```

---

## File I/O (Always Async)
```python
import aiofiles

# ✅ CORRECT
async def read_file(path: str) -> str:
    async with aiofiles.open(path) as f:
        return await f.read()

# ❌ WRONG
def read_file(path: str) -> str:
    with open(path) as f:  # BLOCKS
        return f.read()
```

---

## Configuration (Never Hardcode)
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str
    api_key: str
    debug: bool = False

    class Config:
        env_file = ".env"

settings = Settings()

# Usage
connection = connect(settings.database_url)
```

---

## Entry Point Pattern
```python
if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "module:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
    )
```